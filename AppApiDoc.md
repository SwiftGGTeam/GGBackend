# App 接口文档
## 通用请求返回格式
```json
{
    "success": true,
    "message": "",
    "results": {
 
    }
}
```
## 文章
### 文章列表
| 参数名 | 是否可选 | 备注 |
| --- | --- | --- |
| page | 是 | 页数，默认为 1 |
| size | 是 | 分页大小，默认为 10 |

接口地址：`GET` `http://api.swift.gg/app/posts`

```json
{
    "success": true,
    "message": "",
    "results": {
        "pageBean": {
            "page": 1,
            "size": 10,
            "total": 510
        },
        "items": [
            {
                "id": 486,
                "title": "Swift 关键字",
                "preface": "有句话之前我提过，今天还想再说一次。那就是打铁还需自身硬。对于自身能力的严格要求，可以帮助实现我们所有梦寐以求的东西。\n说起来可能有些消极，知识毕竟是永远学不完的。不论如何，今天 [我们先来学习一下 Swift 中的每一个关键字](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html)（V3.0.1），在介绍每个关键字的时候，同时会附带一段代码加以说明。\n在这些关键字之中，会有你熟悉或者不熟悉的部分。但为了最好的阅读和学习体验，我把它们全部列出来了。文章篇幅有些长，你准备好了么？\n让我们现在就开始吧。",
                "category": "swiftjectivec",
                "publishDate": "2019-08-22"
            },
            {
                "id": 485,
                "title": "给 UIView 来点烟花",
                "preface": "",
                "category": "Tomasz Szulc",
                "publishDate": "2019-08-14"
            },
            {
                "id": 484,
                "title": "Bundles and Packages",
                "preface": "在这个给予的季节，让我们停下脚步，思考一个现代计算机系统赐予我们的最棒的礼物：抽象。\n在数百万 CPU 晶体管、SSD 扇区和 LCD 像素共同协作下，全球数十亿人能够日常使用计算机和移动设备而对此全然不知。这一切都应归功于像文件，目录，应用和文档这样的抽象。\n这周的 NSHipster，我们将讨论苹果平台上两个重要的抽象：包与包裹。🎁",
                "category": "Swift",
                "publishDate": "2019-07-19"
            },
            {
                "id": 483,
                "title": "Swift 中的集合（Set）",
                "preface": "集合（Set）是 Swift 集合类型（collection types）之一，集合用来存储类型相同且没有确定顺序唯一的值。你可以将集合想象成一盒台球：它们在颜色和数量上独一无二，但在盒内是无序的。\n![](/img/articles/Sets-in-Swift/billiard.jpg1562643187.9223473)",
                "category": "thomashanning",
                "publishDate": "2019-07-09"
            },
            {
                "id": 482,
                "title": "PhotoKit 的数据模型",
                "preface": "在 iOS 系统中，[PhotoKit 框架](https://developer.apple.com/documentation/photokit) 不仅被系统的照片 App 所使用，同时它也为开发人员访问设备的照片库提供了接口支持。而它的底层则是 [Core Data](https://developer.apple.com/documentation/coredata) 实现的。",
                "category": "PhotoKit",
                "publishDate": "2019-07-01"
            },
            {
                "id": 481,
                "title": "将 Swift 序列切分为头部和尾部",
                "preface": "函数式编程语言的一个常用范式是把一个列表切分为头部（第一个元素）和尾部（其余元素）。在 Haskell 中，[x:xs](https://en.wikibooks.org/wiki/Haskell/Pattern_matching) 会匹配非空列表，将头部绑定给变量 x，尾部绑定给 xs。\n[Swift 不是一门函数式编程语言](https://academy.realm.io/posts/tryswift-rob-napier-swift-legacy-functional-programming/)。既没有内置的 `List` 类型，也没有集合的特定匹配语法。<a href=\"#foot1\" id=\"1\"><sup>[1]</sup></a>",
                "category": "Ole Begemann",
                "publishDate": "2019-06-24"
            },
            {
                "id": 480,
                "title": "使用 Swift 实现基于堆的优先级队列",
                "preface": "在计算机科学中，有很多问题可以通过将底层数据结构用优先级队列实现来改善算法的时间复杂度。其中 Dijkstra 的最短路径算法便是一个例子，该算法使用了优先级队列来在图中搜索两个顶点间的最短路径。\n不幸的是，Swift 的标准库中并没有提供优先级队列的默认实现。所以我们将会研究如何自行实现基于堆的优先级队列。",
                "category": "AppCoda",
                "publishDate": "2019-05-06"
            },
            {
                "id": 479,
                "title": "Swift 5 字符串插值-简介",
                "preface": " `StringInterpolation` 协议最初的设计效率低下又不易扩展，为了在后续的版本中能够将其彻底重构，Swift 4 中将该协议标记为废弃。即将在 Swift 5 中亮相的 [SE-0228](https://github.com/apple/swift-evolution/blob/master/proposals/0228-fix-expressiblebystringinterpolation.md) 提案介绍了一种新的 `StringInterpolation` 设计，使得 String 有了更大的潜能。",
                "category": "Crunchy Development",
                "publishDate": "2019-04-22"
            },
            {
                "id": 478,
                "title": "在 iOS 11 中使用 Core Bluetooth",
                "preface": "作为 iOS 开发，我们十分清楚人们都喜欢互通性。我们喜欢通过无线设备与其他人进行沟通这一点是显而易见的。最近，我们开始希望能够与那些曾经被认为是独立的普通设备进行*通信*。我们开始喜欢，甚至是期望，部分无线设备可以收集并且分析自己的数据（通常称为“可穿戴设备”）。许多设备已经成为我们生活里的一部分，还为还有一个专门的术语来描述它：“Internet of Things” 或者 “IoT”（物联网）。现在地球上有数十亿的无线通讯设备。在这篇教程中，我们将聚焦 IoT 其中的一部分：蓝牙。  \n我将说明蓝牙技术背后的基本概念，以及：  \n - 展示如何精通蓝牙方向的软件开发，从而为你提供巨大的职业机遇  \n - 提醒你必须去确认在发布一个使用蓝牙技术的应用时是否需要通过“资格审查”  \n - 给你提供 Apple 的[***Core Bluetooth***](https://developer.apple.com/documentation/corebluetooth) 框架概述 ([**也可以参阅这里**](https://developer.apple.com/library/archive/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html#//apple_ref/doc/uid/TP40013257-CH1-SW1))  \n - 最后，带领你使用 Swift 4 并通过 *Core Bluetooth* 和一个蓝牙设备来开发一款用于监控心率的 iOS 应用程序\n> 提示：注意跟随阅读文章中包含的超链接。对于开发者这是重要的资料，它确保你完全理解蓝牙的工作方式以及苹果是如何支持蓝牙这种技术的。",
                "category": "appcoda",
                "publishDate": "2019-04-15"
            },
            {
                "id": 477,
                "title": "Void",
                "preface": "从 [我们第一篇关于 Objective-C 中的 `nil` 的文章](https://nshipster.com/nil/) 到 [最近对 Swift 中 `Never` 类型的一瞥](https://nshipster.com/never/)，“不存在”一直是 NSHipster 讨论的话题。但今天的文章可能是它们当中充斥着最多如 [恐怖留白](https://en.wikipedia.org/wiki/Horror_vacui) 般细节的 —— 因为我们将目光聚焦在了 Swift 中的 `Void` 上。",
                "category": "Swift",
                "publishDate": "2019-02-25"
            }
        ]
    }
}
```

### 文章详情
接口地址：`GET` `http://api.swift.gg/app/post/[:id]`

例：http://api.swift.gg/app/post/486

```json
{
    "success": true,
    "message": "",
    "results": {
        "id": 486,
        "title": "Swift 关键字",
        "body": "> 作者：Jordan Morgan，[原文链接](https://www.swiftjectivec.com/swift-keywords-v-3-0-1/)，原文日期：2017-02-11\n> 译者：[郑一一](https://www.jianshu.com/u/076cc5e18bb8)；校对：[numbbbbb](http://numbbbbb.com/)，[pmst](http://www.jianshu.com/users/596f2ba91ce9/latest_articles)；定稿：[Pancf](https://github.com/Pancf)\n  \n\n\n\n\n\n\n\n\n<!--此处开始正文-->\n\n有句话之前我提过，今天还想再说一次。那就是打铁还需自身硬。对于自身能力的严格要求，可以帮助实现我们所有梦寐以求的东西。\n\n说起来可能有些消极，知识毕竟是永远学不完的。不论如何，今天 [我们先来学习一下 Swift 中的每一个关键字](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html)（V3.0.1），在介绍每个关键字的时候，同时会附带一段代码加以说明。\n\n在这些关键字之中，会有你熟悉或者不熟悉的部分。但为了最好的阅读和学习体验，我把它们全部列出来了。文章篇幅有些长，你准备好了么？\n\n让我们现在就开始吧。\n\n<!--more-->\n\n## 声明式关键字\n\n**associatedtype**：在协议中，定义一个类型的占位符名称。直到协议被实现，该占位符才会被指定具体的类型。\n\n```swift\nprotocol Entertainment  \n{  \n    associatedtype MediaType  \n}\n\nclass Foo : Entertainment  \n{  \n    typealias MediaType = String //可以指定任意类型\n}\n```\n\n**class**：通用、灵活的结构体，是程序的基础组成部分。与 struct 类似，不同之处在于：\n\n* 允许一个类继承另一个类的特性。\n* 类型转换，允许在运行时检查和指定一个类的实际类型。\n* 析构方法允许类的实例释放所有资源。\n* 引用计数允许多个引用指向一个实例。\n\n```swift\nclass Person  \n{  \n    var name:String  \n    var age:Int  \n    var gender:String  \n}\n```\n\n**deinit**：当一个类的实例即将被销毁时，会调用这个方法。\n\n```swift\nclass Person  \n{  \n    var name:String  \n    var age:Int  \n    var gender:String\n\n    deinit  \n    {  \n        //从堆中释放，并释放的资源\n    }  \n}\n```\n\n**enum**：定义了包含一组有关联的值的类型，并可以以一种类型安全的方式使用这些值。在 Swift 中，枚举是一等类型，拥有在其它语言中只有 class 才会支持的特性。\n\n```swift\nenum Gender  \n{  \n    case male  \n    case female  \n}\n```\n\n**extension**：允许给已有的类、结构体、枚举、协议类型，添加新功能。\n\n```swift\nclass Person  \n{  \n    var name:String = \"\"  \n    var age:Int = 0  \n    var gender:String = \"\"  \n}\n\nextension Person  \n{  \n    func printInfo()  \n    {  \n        print(\"My name is \\(name), I'm \\(age) years old and I'm a \\(gender).\")  \n    }  \n}\n```\n\n**fileprivate**：访问控制权限，只允许在定义源文件中访问。\n\n```swift\nclass Person  \n{  \n    fileprivate var jobTitle:String = \"\"  \n}\n\nextension Person  \n{\n    //当 extension 和 class 在同一个文件中时，允许访问\n    func printJobTitle()  \n    {  \n        print(\"My job is (jobTitle)\")  \n    }  \n}\n```\n\n**func**：包含用于执行特定任务的代码块。\n\n```swift\nfunc addNumbers(num1:Int, num2:Int) -> Int  \n{  \n    return num1+num2  \n}\n```\n\n**import**：引入一个以独立单元构建的框架或者应用。\n\n```swift\nimport UIKit\n\n//可以使用 UIKit 框架下的所有代码\nclass Foo {}\n```\n\n**init**：类、结构体、枚举的实例的初始化准备过程。\n\n```swift\nclass Person\n{  \n    init()  \n    {  \n        //设置默认值，实例准备被使用\n    }  \n}\n```\n\n**inout**：将一个值传入函数，并可以被函数修改，然后将值传回到调用处，来替换初始值。适用于引用类型和值类型。\n\n```swift\nfunc dangerousOp(_ error:inout NSError?)  \n{  \n    error = NSError(domain: \"\", code: 0, userInfo: [\"\":\"\"])  \n}\n\nvar potentialError:NSError?\ndangerousOp(&potentialError)\n\n//代码运行到这里，potentialError 不再是 nil，而是已经被初始化\n```\n\n**internal**：访问控制权限，允许同一个模块下的所有源文件访问，如果在不同模块下则不允许访问。\n\n```swift\nclass Person  \n{  \n    internal var jobTitle:String = \"\"  \n}\n\nlet aPerson = Person()  \naPerson.jobTitle = \"This can set anywhere in the application\"\n```\n\n**let**：定义一个不可变的变量。\n\n```swift\nlet constantString = \"This cannot be mutated going forward\"\n```\n\n**open**：访问控制权限，允许在定义的模块外也可以访问源文件里的所有类，并进行子类化。对于类成员，允许在定义的模块之外访问和重写。\n\n```swift\nopen var foo:String? //这个属性允许在 app 内或 app 外重写和访问。在开发框架的时候，会应用到这个访问修饰符。\n```\n\n**operator**：特殊符号，用于检查、修改、组合值。\n\n```swift\n//一元运算符 \"-\"，改变值的符号\nlet foo = 5  \nlet anotherFoo = -foo //anotherFoo 等于 -5\n\n//二元运算符 \"+\" 将两个值相加\nlet box = 5 + 3\n\n//逻辑运算符 \"&&\" 将两个布尔值进行组合运算\nif didPassCheckOne && didPassCheckTwo\n\n//三元运算符需要使用三个值\nlet isLegalDrinkingAgeInUS:Bool = age >= 21 ? true : false\n```\n\n**private**：访问控制权限，只允许实体在定义的类以及相同源文件内的 extension 中访问。\n\n```swift\nclass Person  \n{  \n    private var jobTitle:String = \"\"  \n}\n\n// 当 extension 和 class 不在同一个源文件时\nextension Person  \n{\n    // 无法编译通过，只有在同一个源文件下才可以访问\n    func printJobTitle()  \n    {  \n        print(\"My job is (jobTitle)\")  \n    }  \n}\n```\n\n**protocol**：定义了一组方法、属性或其它要求，用于满足特定任务和一系列功能。\n\n```swift\nprotocol Blog  \n{  \n    var wordCount:Int { get set }  \n    func printReaderStats()  \n}\n\nclass TTIDGPost : Blog  \n{  \n    var wordCount:Int\n\n    init(wordCount:Int)  \n    {  \n        self.wordCount = wordCount  \n    }\n\n    func printReaderStats()  \n    {  \n        //打印 post 的数据  \n    }  \n}\n```\n\n**public**：访问控制权限，允许在定义的模块外也可以访问源文件里的所有类，但只有在同一个模块内可以进行子类化。对于类成员，允许在同个模块下访问和重写。\n\n```swift\npublic var foo:String? //只允许在 app 内重写和访问。\n```\n\n**static**：用于定义类方法，在类型本身进行调用。此外还可以定义静态成员。\n\n```swift\nclass Person  \n{  \n    var jobTitle:String?\n\n    static func assignRandomName(_ aPerson:Person)  \n    {  \n        aPerson.jobTitle = \"Some random job\"  \n    }  \n}\n\nlet somePerson = Person()  \nPerson.assignRandomName(somePerson)  \n//somePerson.jobTitle 的值是 \"Some random job\"\n```\n\n**struct**：通用、灵活的结构体，是程序的基础组成部分，并提供了默认初始化方法。与 class 不同，当 struct 在代码中被传递时，是被拷贝的，并不使用引用计数。除此之外，struct 没有下面的这些功能：\n\n* 使用继承。\n* 运行时的类型转换。\n* 使用析构方法。\n\n```swift\nstruct Person  \n{  \n    var name:String  \n    var age:Int  \n    var gender:String  \n}\n```\n\n**subscript**：访问集合、列表、序列中成员元素的快捷方式。\n\n```swift\nvar postMetrics = [\"Likes\":422, \"ReadPercentage\":0.58, \"Views\":3409]  \nlet postLikes = postMetrics[\"Likes\"]\n```\n\n**typealias**：给代码中已经存在的类，取别名。\n\n```swift\ntypealias JSONDictionary = [String: AnyObject]\n\nfunc parseJSON(_ deserializedData:JSONDictionary){}\n```\n\n**var**：定义可变变量。\n\n```swift\nvar mutableString = \"\"  \nmutableString = \"Mutated\"\n```\n\n## 语句中的关键词\n\n**break**：终止程序中循环的执行，比如 if 语句、switch 语句。\n\n```swift\nfor idx in 0...3  \n{  \n    if idx % 2 == 0  \n    {  \n        //当 idx 等于偶数时，退出 for 循环  \n        break  \n    }  \n}\n```\n\n**case**：该语句在 switch 语句中列出，在每个分支可以进行模式匹配。\n\n```swift\nlet box = 1\n\nswitch box  \n{  \n    case 0:  \n    print(\"Box equals 0\")  \n    case 1:  \n    print(\"Box equals 1\")  \n    default:  \n    print(\"Box doesn't equal 0 or 1\")  \n}\n```\n\n**continue**：用于终止循环的当前迭代，并进入下一次迭代，而不会停止整个循环的执行。\n\n```swift\nfor idx in 0...3  \n{  \n    if idx % 2 == 0  \n    {  \n        //直接开始循环的下一次迭代\n        continue  \n    }\n\n    print(\"This code never fires on even numbers\")  \n}\n```\n\n**default**：用于涵盖在 switch 语句中，所有未明确列出的枚举成员。\n\n```swift\nlet box = 1\n\nswitch box  \n{  \n    case 0:  \n    print(\"Box equals 0\")  \n    case 1:  \n    print(\"Box equals 1\")  \n    default:  \n    print(\"Covers any scenario that doesn't get addressed above.\")  \n}\n```\n\n**defer**：用于在程序离开当前作用域之前，执行一段代码。\n\n```swift\nfunc cleanUpIO()  \n{  \n    defer  \n    {  \n        print(\"This is called right before exiting scope\")  \n    }\n\n\n    //关闭文件流等。  \n}\n```\n\n**do**：用于表示处理错误代码段的开始。\n\n```swift\ndo  \n{  \n    try expression  \n    //语句\n}  \ncatch someError ex  \n{  \n    //处理错误\n}\n```\n\n**else**：与 if 语句结合使用。当条件为 true，执行一段代码。当条件为 false，执行另一段代码。\n\n```swift\nif val > 1  \n{  \n    print(\"val is greater than 1\")  \n}  \nelse  \n{  \n    print(\"val is not greater than 1\")  \n}\n```\n\n**fallthrough**：显式地允许从当前 case 跳转到下一个相邻 case 继续执行代码。\n\n```swift\nlet box = 1\n\nswitch box  \n{  \n    case 0:  \n    print(\"Box equals 0\")  \n    fallthrough  \n    case 1:  \n    print(\"Box equals 0 or 1\")  \n    default:  \n    print(\"Box doesn't equal 0 or 1\")  \n}\n```\n\n**for**：在序列上迭代，比如一组特定范围内的数字，数组中的元素，字符串中的字符。\\*与关键字 in 成对使用。\n\n```swift\nfor _ in 0..<3 { print (\"This prints 3 times\") }\n```\n\n**guard**：当有一个以上的条件不满足要求时，将离开当前作用域。同时还提供解包可选类型的功能。\n\n```swift\nprivate func printRecordFromLastName(userLastName: String?)\n{  \n    guard let name = userLastName, name != \"Null\" else  \n    {  \n        //userLastName = \"Null\"，需要提前退出\n        return  \n    }\n\n    //继续执行代码\n    print(dataStore.findByLastName(name))  \n}\n```\n\n**if**：当条件满足时，执行代码。\n\n```swift\nif 1 > 2  \n{  \n    print(\"This will never execute\")  \n}\n```\n\n**in**：在序列上迭代，比如一组特定范围内的数字，数组中的元素，字符串中的字符。\\*与关键字 key 搭配使用。\n\n```swift\nfor _ in 0..<3 { print (\"This prints 3 times\") }\n```\n\n**repeat**：在使用循环的判断条件之前，先执行一次循环中的代码。\n\n```swift\nrepeat  \n{  \n    print(\"Always executes at least once before the condition is considered\")  \n}  \nwhile 1 > 2\n```\n\n**return**：立刻终止当前上下文，离开当前作用域，此外在返回时可以额外携带一个值。\n\n```swift\nfunc doNothing()  \n{  \n    return //直接离开当前上下文\n\n    let anInt = 0  \n    print(\"This never prints (anInt)\")  \n}\n```\n\n和\n\n```swift\nfunc returnName() -> String?  \n{  \n    return self.userName //离开，并返回 userName 的值\n}\n```\n\n**switch**：将给定的值与分支进行比较。执行第一个模式匹配成功的分支代码。\n\n```swift\nlet box = 1\n\nswitch box  \n{  \n    case 0:  \n    print(\"Box equals 0\")  \n    fallthrough  \n    case 1:  \n    print(\"Box equals 0 or 1\")  \n    default:  \n    print(\"Box doesn't equal 0 or 1\")  \n}\n```\n\n**where**：要求关联类型必须遵守特定协议，或者类型参数和关联类型必须保持一致。也可以用于在 case 中提供额外条件，用于满足控制表达式。\n\n> where 从句可以应用于多种场景。以下例子指明了 where 的主要应用场景，泛型中的模式匹配。\n\n```swift\nprotocol Nameable  \n{  \n    var name:String {get set}  \n}\n\nfunc createdFormattedName(_ namedEntity:T) -> String where T:Equatable  \n{  \n    //只有当实体同时遵守 Nameable 和 Equatable 协议的时候，才允许调用这个函数\n    return \"This things name is \" + namedEntity.name  \n}\n```\n\n和\n\n```swift\nfor i in 0…3 where i % 2 == 0  \n{  \n    print(i) //打印 0 和 2  \n}\n```\n\n**while**：循环执行特定的一段语句，直到条件不满足时，停止循环。\n\n```swift\nwhile foo != bar  \n{  \n    print(\"Keeps going until the foo == bar\")  \n}\n```\n\n## 表达式和类型中的关键字\n\n**Any**：用于表示任意类型的实例，包括函数类型。\n\n```swift\nvar anything = [Any]()\n\nanything.append(\"Any Swift type can be added\")  \nanything.append(0)  \nanything.append({(foo: String) -> String in \"Passed in (foo)\"})\n```\n\n**as**：类型转换运算符，用于尝试将值转成其它类型。\n\n```swift\nvar anything = [Any]()\n\nanything.append(\"Any Swift type can be added\")  \nanything.append(0)  \nanything.append({(foo: String) -> String in \"Passed in (foo)\" })\n\nlet intInstance = anything[1] as? Int\n```\n\n或者\n\n```swift\nvar anything = [Any]()\n\nanything.append(\"Any Swift type can be added\")  \nanything.append(0)  \nanything.append({(foo: String) -> String in \"Passed in (foo)\" })\n\nfor thing in anything  \n{  \n    switch thing  \n    {  \n        case 0 as Int:  \n        print(\"It's zero and an Int type\")  \n        case let someInt as Int:  \n        print(\"It's an Int that's not zero but (someInt)\")  \n        default:  \n        print(\"Who knows what it is\")  \n    }  \n}\n```\n\n**catch**：如果在 do 中抛出一个错误，catch 会尝试进行匹配，并决定如何处理错误。[\\*我写的一篇 Swift 错误处理的博客节选](https://swiftjectivec.com/swift-error-handling)。\n\n```swift\ndo  \n{  \n    try haveAWeekend(4)  \n}  \ncatch WeekendError.Overtime(let hoursWorked)  \n{  \n    print(\"You worked (hoursWorked) more than you should have\")  \n}  \ncatch WeekendError.WorkAllWeekend  \n{  \n    print(\"You worked 48 hours :-0\")  \n}  \ncatch  \n{  \n    print(\"Gulping the weekend exception\")  \n}\n```\n\n**false**：Swift 用于表示布尔值的两个常量值之一，true 的相反值。\n\n```swift\nlet alwaysFalse = false  \nlet alwaysTrue = true\n\nif alwaysFalse { print(\"Won't print, alwaysFalse is false 😉\")}\n```\n\n**is**：类型检查运算符，用于确定实例是否为某个子类类型。\n\n```swift\nclass Person {}  \nclass Programmer : Person {}  \nclass Nurse : Person {}\n\nlet people = [Programmer(), Nurse()]\n\nfor aPerson in people  \n{  \n    if aPerson is Programmer  \n    {  \n        print(\"This person is a dev\")  \n    }  \n    else if aPerson is Nurse  \n    {  \n        print(\"This person is a nurse\")  \n    }  \n}\n```\n\n**nil**：在 Swift 中表示任意类型的无状态值。\n\n> 与 Objective-C 中的 nil 不同，Objective-C 中的 nil 表示指向不存在对象的指针。\n\n```swift\nclass Person{}  \nstruct Place{}\n\n//任何 Swift 类型或实例可以为 nil\nvar statelessPerson:Person? = nil  \nvar statelessPlace:Place? = nil  \nvar statelessInt:Int? = nil  \nvar statelessString:String? = nil\n```\n\n**rethrows**：指明当前函数只有当参数抛出 error 时，才会抛出 error。\n\n```swift\nfunc networkCall(onComplete:() throws -> Void) rethrows  \n{  \n    do  \n    {  \n        try onComplete()  \n    }  \n    catch  \n    {  \n        throw SomeError.error  \n    }  \n}\n```\n\n**super**：在子类中，暴露父类的方法、属性、下标。\n\n```swift\nclass Person  \n{  \n    func printName()  \n    {  \n        print(\"Printing a name. \")  \n    }  \n}\n\nclass Programmer : Person  \n{  \n    override func printName()  \n    {  \n        super.printName()  \n        print(\"Hello World!\")  \n    }  \n}\n\nlet aDev = Programmer()  \naDev.printName() //打印 Printing a name. Hello World!\n```\n\n**self**：任何类型的实例都拥有的隐式属性，等同于实例本身。此外还可以用于区分函数参数和成员属性名称相同的情况。\n\n```swift\nclass Person  \n{  \n    func printSelf()  \n    {  \n        print(\"This is me: (self)\")  \n    }  \n}\n\nlet aPerson = Person()  \naPerson.printSelf() //打印 \"This is me: Person\"\n```\n\n**Self**：在协议中，表示遵守当前协议的实体类型。\n\n```swift\nprotocol Printable  \n{  \n    func printTypeTwice(otherMe:Self)  \n}\n\nstruct Foo : Printable  \n{  \n    func printTypeTwice(otherMe: Foo)  \n    {  \n        print(\"I am me plus (otherMe)\")  \n    }  \n}\n\nlet aFoo = Foo()  \nlet anotherFoo = Foo()\n\naFoo.printTypeTwice(otherMe: anotherFoo) //打印 I am me plus Foo()\n```\n\n**throw**：用于在当前上下文，显式抛出 error。\n\n```swift\nenum WeekendError: Error  \n{  \n    case Overtime  \n    case WorkAllWeekend  \n}\n\nfunc workOvertime () throws  \n{  \n    throw WeekendError.Overtime  \n}\n```\n\n**throws**：指明在一个函数、方法、初始化方法中可能会抛出 error。\n\n```swift\nenum WeekendError: Error  \n{  \n    case Overtime  \n    case WorkAllWeekend  \n}\n\nfunc workOvertime () throws  \n{  \n    throw WeekendError.Overtime  \n}\n\n//\"throws\" 表明在调用方法时，需要使用 try，try?，try!\ntry workOvertime()\n```\n\n**true**：Swift 用于表示布尔值的两个常量值之一，表示为真。\n\n```swift\nlet alwaysFalse = false  \nlet alwaysTrue = true\n\nif alwaysTrue { print(\"Always prints\")}\n```\n\n**try**：表明接着调用的函数可能会抛出 error。有三种不同的使用方式：try，try?， try!。\n\n```swift\nlet aResult = try dangerousFunction() //处理 error，或者继续传递 error  \nlet aResult = try! dangerousFunction() //程序可能会闪退  \nif let aResult = try? dangerousFunction() //解包可选类型。\n```\n\n## 模式中的关键字\n\n**_**：用于匹配或省略任意值的通配符。\n\n```swift\nfor _ in 0..<3  \n{  \n    print(\"Just loop 3 times, index has no meaning\")  \n}\n```\n\n另外一种用法：\n\n```swift\nlet _ = Singleton() //忽略不使用的变量\n```\n\n## 以#开头的关键字\n\n**#available**：基于平台参数，通过 **if**，**while**，**guard** 语句的条件，在运行时检查 API 的可用性。\n\n```swift\nif #available(iOS 10, *)  \n{  \n    print(\"iOS 10 APIs are available\")  \n}\n```\n\n**#colorLiteral**：在 playground 中使用的字面表达式，用于创建颜色选取器，选取后赋值给变量。\n\n```swift\nlet aColor = #colorLiteral //创建颜色选取器\n```\n\n**#column**：一种特殊的字面量表达式，用于获取字面量表示式的起始列数。\n\n```swift\nclass Person  \n{  \n    func printInfo()  \n    {  \n        print(\"Some person info - on column (#column)\")\n    }  \n}\n\nlet aPerson = Person()  \naPerson.printInfo() //Some person info - on column 53\n```\n\n**#else**：条件编译控制语句，用于控制程序在不同条件下执行不同代码。与 **#if** 语句结合使用。当条件为 true，执行对应代码。当条件为 false，执行另一段代码。\n\n```swift\n#if os(iOS)  \nprint(\"Compiled for an iOS device\")  \n#else  \nprint(\"Not on an iOS device\")  \n#endif\n```\n\n**#elseif**：条件编译控制语句，用于控制程序在不同条件下执行代码。与 **#if** 语句结合使用。当条件为 true，执行对应代码。\n\n```swift\n#if os(iOS)  \nprint(\"Compiled for an iOS device\")  \n#elseif os(macOS)  \nprint(\"Compiled on a mac computer\")  \n#endif\n```\n\n**#endif**：条件编译控制语句，用于控制程序在不同条件下执行代码。用于表明条件编译代码的结尾。\n\n```swift\n#if os(iOS)  \nprint(\"Compiled for an iOS device\")  \n#endif\n```\n\n**#file**：特殊字面量表达式，返回当前代码所在源文件的名称。\n\n```swift\nclass Person  \n{  \n    func printInfo()  \n    {  \n        print(\"Some person info - inside file (#file)\")\n    }  \n}\n\nlet aPerson = Person()  \naPerson.printInfo() //Some person info - inside file /*代码所在 playground 文件路径*/\n```\n\n**#fileReference**：playground 字面量语法，用于创建文件选取器，选取并返回 NSURL 实例。\n\n```swift\nlet fontFilePath = #fileReference //创建文件选取器\n```\n\n**#function**：特殊字面量表达式，返回函数名称。在方法中，返回方法名。在属性的 getter 或者 setter 中，返回属性名。在特殊的成员中，比如 init 或 subscript 中，返回关键字名称。在文件的最顶层时，返回当前所在模块名称。\n\n```swift\nclass Person  \n{  \n    func printInfo()  \n    {  \n        print(\"Some person info - inside function (#function)\")\n    }  \n}\n\nlet aPerson = Person()  \naPerson.printInfo() //Some person info - inside function printInfo()\n```\n\n**#if**：条件编译控制语句，用于控制程序在不同条件下编译代码。通过判断条件，决定是否执行代码。\n\n```swift\n#if os(iOS)  \nprint(\"Compiled for an iOS device\")  \n#endif\n```\n\n**#imageLiteral**：playground 字面量语法，创建图片选取器，选择并返回 UIImage 实例。\n\n```swift\nlet anImage = #imageLiteral //在 playground 文件中选取图片\n```\n\n**#line**：特殊字面量表达式，用于获取当前代码的行数。\n\n```swift\nclass Person  \n{  \n    func printInfo()  \n    {  \n        print(\"Some person info - on line number (#line)\")\n    }  \n}\n\nlet aPerson = Person()  \naPerson.printInfo() //Some person info - on line number 5\n```\n\n**#selector**：用于创建 Objective-C selector 的表达式，可以静态检查方法是否存在，并暴露给 Objective-C。\n\n```swift\n//静态检查，确保 doAnObjCMethod 方法存在  \ncontrol.sendAction(#selector(doAnObjCMethod), to: target, forEvent: event)\n```\n\n**#sourceLocation**：行控制语句，可以指定与原先完全不同的行数和源文件名。通常在 Swift 诊断、debug 时使用。\n\n```swift\n#sourceLocation(file:\"foo.swift\", line:6)\n\n//打印新值\nprint(#file)  \nprint(#line)\n\n//重置行数和文件名\n#sourceLocation()\n\nprint(#file)  \nprint(#line)\n```\n\n## 特定上下文中的关键字\n\n> 这些关键字，在处于对应上下文之外时，可以用作标识符。\n\n**associativity**：指明同一优先级的运算符，在缺少大括号的情况，按什么顺序结合。使用 **left**、**right**、**none**。\n\n```swift\ninfix operator ~ { associativity right precedence 140 }  \n4 ~ 8\n```\n\n**convenience**：次等的便利构造器，最后会调用指定构造器初始化实例。\n\n```swift\nclass Person  \n{  \n    var name:String\n\n    init(_ name:String)  \n    {  \n        self.name = name  \n    }\n\n    convenience init()  \n    {  \n        self.init(\"No Name\")  \n    }  \n}\n\nlet me = Person()  \nprint(me.name)//打印 \"No Name\"\n```\n\n**dynamic**：指明编译器不会对类成员或者函数的方法进行内联或虚拟化。这意味着对这个成员的访问是使用 Objective-C 运行时进行动态派发的（代替静态调用）。\n\n```swift\nclass Person  \n{  \n    //隐式指明含有 \"objc\" 属性\n    //这对依赖于 Objc-C 黑魔法的库或者框架非常有用\n    //比如 KVO、KVC、Swizzling\n    dynamic var name:String?  \n}\n```\n\n**didSet**：属性观察者，当值存储到属性后马上调用。\n\n```swift\nvar data = [1,2,3]  \n{  \n    didSet  \n    {  \n        tableView.reloadData()  \n    }  \n}\n```\n\n**final**：防止方法、属性、下标被重写。\n\n```swift\nfinal class Person {}  \nclass Programmer : Person {} //编译错误\n```\n\n**get**：返回成员的值。还可以用在计算型属性上，间接获取其它属性的值。\n\n```swift\nclass Person  \n{  \n    var name:String  \n    {  \n        get { return self.name }  \n        set { self.name = newValue}  \n    }\n\n    var indirectSetName:String  \n    {  \n        get  \n        {  \n            if let aFullTitle = self.fullTitle  \n            {  \n                return aFullTitle  \n            }  \n            return \"\"  \n        }\n\n        set (newTitle)  \n        {  \n            //如果没有定义 newTitle，可以使用 newValue\n            self.fullTitle = \"(self.name) :(newTitle)\"  \n        }\n    }  \n}\n```\n\n**infix**：指明一个用于两个值之间的运算符。如果一个全新的全局运算符被定义为 infix，还需要指定优先级。\n\n```swift\nlet twoIntsAdded = 2 + 3\n```\n\n**indirect**：指明在枚举类型中，存在成员使用相同枚举类型的实例作为关联值的情况。\n\n```swift\nindirect enum Entertainment  \n{  \n    case eventType(String)  \n    case oneEvent(Entertainment)  \n    case twoEvents(Entertainment, Entertainment)  \n}\n\nlet dinner = Entertainment.eventType(\"Dinner\")  \nlet movie = Entertainment.eventType(\"Movie\")\n\nlet dateNight = Entertainment.twoEvents(dinner, movie)\n```\n\n**lazy**：指明属性的初始值，直到第一次被使用时，才进行初始化。\n\n```swift\nclass Person  \n{  \n    lazy var personalityTraits = {  \n        //昂贵的数据库开销  \n        return [\"Nice\", \"Funny\"]  \n    }()  \n}\nlet aPerson = Person()  \naPerson.personalityTraits //当 personalityTraits 首次被访问时，数据库才开始工作\n```\n\n**left**：指明运算符的结合性是从左到右。在没有使用大括号时，可以用于正确判断同一优先级运算符的执行顺序。\n\n```swift\n//\"-\" 运算符的结合性是从左到右\n10-2-4 //根据结合性，可以看做 (10-2) - 4\n```\n\n**mutating**：允许在方法中修改结构体或者枚举实例的属性值。\n\n```swift\nstruct Person  \n{  \n    var job = \"\"\n\n    mutating func assignJob(newJob:String)  \n    {  \n        self = Person(job: newJob)  \n    }  \n}\n\nvar aPerson = Person()  \naPerson.job //\"\"\n\naPerson.assignJob(newJob: \"iOS Engineer at Buffer\")  \naPerson.job //iOS Engineer at Buffer\n```\n\n**none**：是一个没有结合性的运算符。不允许这样的运算符相邻出现。\n\n```swift\n//\"<\" 是非结合性的运算符\n1 < 2 < 3 //编译失败\n```\n\n**nonmutating**：指明成员的 setter 方法不会修改实例的值，但可能会有其它后果。\n\n```swift\nenum Paygrade  \n{  \n    case Junior, Middle, Senior, Master\n\n    var experiencePay:String?  \n    {  \n        get  \n        {  \n            database.payForGrade(String(describing:self))  \n        }\n\n        nonmutating set  \n        {  \n            if let newPay = newValue  \n            {  \n                database.editPayForGrade(String(describing:self), newSalary:newPay)  \n            }  \n        }  \n    }  \n}\n\nlet currentPay = Paygrade.Middle\n\n//将 Middle pay 更新为 45k, 但不会修改 experiencePay 值\ncurrentPay.experiencePay = \"$45,000\"\n```\n\n**optional**：用于指明协议中的可选方法。遵守该协议的实体类可以不实现这个方法。\n\n```swift\n@objc protocol Foo  \n{  \n    func requiredFunction()  \n    @objc optional func optionalFunction()  \n}\n\nclass Person : Foo  \n{  \n    func requiredFunction()  \n    {  \n        print(\"Conformance is now valid\")  \n    }  \n}\n```\n\n**override**：指明子类会提供自定义实现，覆盖父类的实例方法、类型方法、实例属性、类型属性、下标。如果没有实现，则会直接继承自父类。\n\n```swift\nclass Person  \n{  \n    func printInfo()  \n    {  \n        print(\"I'm just a person!\")  \n    }  \n}\n\nclass Programmer : Person  \n{  \n    override func printInfo()  \n    {  \n        print(\"I'm a person who is a dev!\")  \n    }  \n}\n\nlet aPerson = Person()  \nlet aDev = Programmer()\n\naPerson.printInfo() //打印 I'm just a person!  \naDev.printInfo() //打印 I'm a person who is a dev!\n```\n\n**postfix**：位于值后面的运算符。\n\n```swift\nvar optionalStr:String? = \"Optional\"  \nprint(optionalStr!)\n```\n\n**precedence**：指明某个运算符的优先级高于别的运算符，从而被优先使用。\n\n```swift\ninfix operator ~ { associativity right precedence 140 }  \n4 ~ 8\n```\n\n**prefix**：位于值前面的运算符。\n\n```swift\nvar anInt = 2  \nanInt = -anInt //anInt 等于 -2\n```\n\n**required**：确保编译器会检查该类的所有子类，全部实现了指定的构造器方法。\n\n```swift\nclass Person  \n{  \n    var name:String?\n\n    required init(_ name:String)  \n    {  \n        self.name = name  \n    }  \n}\n\nclass Programmer : Person  \n{  \n    //如果不实现这个方法，编译不会通过\n    required init(_ name: String)  \n    {  \n        super.init(name)  \n    }  \n}\n```\n\n**right**：指明运算符的结合性是从右到左的。在没有使用大括号时，可以用于正确判断同一优先级运算符的顺序。\n\n```swift\n//\"??\" 运算符结合性是从右到左\nvar box:Int?  \nvar sol:Int? = 2\n\nlet foo:Int = box ?? sol ?? 0 //Foo 等于 2\n```\n\n**set**：通过获取的新值来设置成员的值。同样可以用于计算型属性来间接设置其它属性。如果计算型属性的 setter 没有定义新值的名称，可以使用默认的 newValue。\n\n```swift\nclass Person  \n{  \n    var name:String  \n    {  \n        get { return self.name }  \n        set { self.name = newValue}  \n    }\n\n    var indirectSetName:String  \n    {  \n        get  \n        {  \n            if let aFullTitle = self.fullTitle  \n            {  \n                return aFullTitle  \n            }  \n            return \"\"  \n        }\n\n        set (newTitle)  \n        {  \n            //如果没有定义 newTitle，可以使用 newValue\n            self.fullTitle = \"(self.name) :(newTitle)\"  \n        }  \n    }  \n}\n```\n\n**Type**：表示任意类型的类型，包括类类型、结构类型、枚举类型、协议类型。\n\n```swift\nclass Person {}  \nclass Programmer : Person {}\n\nlet aDev:Programmer.Type = Programmer.self\n```\n\n**unowned**：让循环引用中的实例 A 不要强引用实例 B。前提条件是实例 B 的生命周期要长于 A 实例。\n\n```swift\nclass Person  \n{  \n    var occupation:Job?  \n}\n\n//当 Person 实例不存在时，job 也不会存在。job 的生命周期取决于持有它的 Person。\nclass Job  \n{  \n    unowned let employee:Person\n\n    init(with employee:Person)  \n    {  \n        self.employee = employee  \n    }  \n}\n```\n\n**weak**：允许循环引用中的实例 A 弱引用实例 B ，而不是强引用。实例 B 的生命周期更短，并会被先释放。\n\n```swift\nclass Person  \n{  \n    var residence:House?  \n}\n\nclass House  \n{  \n    weak var occupant:Person?  \n}\n\nvar me:Person? = Person()  \nvar myHome:House? = House()\n\nme!.residence = myHome  \nmyHome!.occupant = me\n\nme = nil  \nmyHome!.occupant // myHome 等于 nil\n```\n\n**willSet**：属性观察者，在值存储到属性之前调用。\n\n```swift\nclass Person  \n{  \n    var name:String?  \n    {  \n        willSet(newValue) {print(\"I've got a new name, it's (newValue)!\")}  \n    }  \n}\n\nlet aPerson = Person()  \naPerson.name = \"Jordan\" //在赋值之前，打印 \"I've got a new name, it's Jordan!\"\n```\n\n## 总结\n哇噢！\n\n这真是一次有趣的创作。我学会了好多在写之前没想到的东西。但我认为这里的诀窍并不是要把它记住，而是把它当做一份可以用于测验的定义清单。\n\n相反地，我建议你把这份清单放在手边，并时不时地回顾一下。如果你能这样做的话，下一次在不同场景下需要使用特定的关键字，你肯定就能马上回想起来并使用它啦。\n\n下回再见咯。\n\n> 本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 [http://swift.gg](http://swift.gg)。\n"
    }
}
```
